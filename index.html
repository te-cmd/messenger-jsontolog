<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Messenger JSON â†’ Log (ZIP support)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: Inter, sans-serif; font-weight: 600; background: #fafafa; padding: 20px; }
    .log-line { margin: 2px 0; font-family: monospace; }
    .log-link { color: #007aff; text-decoration: underline; cursor: pointer; }
    #media { margin-top: 20px; }
  </style>
</head>
<body>
  <h2>Messenger JSON to Log Converter (ZIP)</h2>
  <input type="file" id="fileInput" accept=".zip,.json" />
  <button id="convertBtn">Convert</button>
  <div id="output"></div>
  <div id="media"></div>
  <a id="downloadLink" style="display:none;">Download .log file</a>

  <script>
  const playableExts = [".ogg", ".wav", ".mp4", ".mp3", ".jpeg", ".jpg", ".png"];

  const badWords = ["fuck","Fuck","shit","Shit","bitch","Bitch","gago","bobo","Bobo","tanga","FUCK","TANGINAINA","Puta","PUTA","HAYOPKA","sh!t","SH1T"];

  let swearCount = 0;
  let userSwears = {};
  let totalMessages = 0;
  let userMessages = {};

  function filterText(text, sender) {
    let result = text;
    badWords.forEach(word => {
      const regex = new RegExp(word, "g");
      if (regex.test(result)) {
        const matches = result.match(regex);
        if (matches) {
          swearCount += matches.length;
          if (!userSwears[sender]) userSwears[sender] = 0;
          userSwears[sender] += matches.length;
        }
      }
      result = result.replace(regex, match => "#".repeat(match.length));
    });
    return result;
  }

  document.getElementById("convertBtn").addEventListener("click", async () => {
    swearCount = 0; userSwears = {}; totalMessages = 0; userMessages = {};
    const fileInput = document.getElementById("fileInput").files[0];
    if (!fileInput) return alert("Please choose a ZIP or JSON file first.");

    const outputDiv = document.getElementById("output");
    outputDiv.innerHTML = "";
    const mediaDiv = document.getElementById("media");
    mediaDiv.innerHTML = "";

    const logLines = [];

    if (fileInput.name.endsWith(".json")) {
      // fallback single JSON
      const text = await fileInput.text();
      processMessages(JSON.parse(text).messages || [], outputDiv, logLines);
      finishLog(logLines);
    } else {
      // ZIP handling
      const jszip = new JSZip();
      const zip = await jszip.loadAsync(fileInput);

      let allMessages = [];
      let mediaFiles = {};

      for (const [path, entry] of Object.entries(zip.files)) {
        if (entry.dir) continue;
        if (path.toLowerCase().endsWith(".json") && !path.startsWith("media/")) {
          const txt = await entry.async("string");
          try {
            const json = JSON.parse(txt);
            if (Array.isArray(json.messages)) {
              allMessages = allMessages.concat(json.messages);
            }
          } catch (e) {
            console.warn("Skipping bad JSON:", path);
          }
        } else if (path.startsWith("media/")) {
          mediaFiles[path] = entry;
        }
      }

      // process messages
      processMessages(allMessages, outputDiv, logLines, mediaFiles);
      finishLog(logLines);
    }
  });

  function processMessages(messages, outputDiv, logLines, mediaFiles={}) {
    messages.forEach(msg => {
      const sender = msg.senderName || "Unknown";
      let ts = "Unknown time";

      if (msg.timestamp) {
        const d = new Date(msg.timestamp);
        if (!isNaN(d.getTime())) {
          ts = d.toISOString().replace("T", " ").split(".")[0];
        }
      }

      totalMessages++;
      if (!userMessages[sender]) userMessages[sender] = 0;
      userMessages[sender]++;

      let text = msg.text && msg.text.trim() ? filterText(msg.text, sender) : "";
      let displayLine = document.createElement("div");
      displayLine.className = "log-line";

      let lineText = `[${ts}] ${sender}: `;

      if (msg.media && msg.media.length > 0) {
        msg.media.forEach(m => {
          const uri = m.uri || "";
          const lower = uri.toLowerCase();
          let tagText = playableExts.some(ext => lower.endsWith(ext))
            ? `[Media: ${uri}]`
            : `[File: ${uri}]`;

          const a = document.createElement("a");
          a.textContent = tagText;
          a.className = "log-link";
          a.target = "_blank";

          if (mediaFiles["media/" + uri]) {
            mediaFiles["media/" + uri].async("blob").then(blob => {
              a.href = URL.createObjectURL(blob);
            });
          } else {
            a.href = uri;
          }

          displayLine.appendChild(document.createTextNode(lineText + (text ? text + " " : "")));
          displayLine.appendChild(a);
          lineText += (text ? text + " " : "") + tagText;
        });
      } else {
        if (!text) text = "[Empty message]";
        lineText += text;
        displayLine.textContent = lineText;
      }

      outputDiv.appendChild(displayLine);
      logLines.push(lineText);
    });
  }

  function finishLog(logLines) {
    const outputDiv = document.getElementById("output");

    const countDiv = document.createElement("div");
    countDiv.style.marginTop = "15px";
    countDiv.style.fontWeight = "bold";
    countDiv.textContent = `Total swears detected: ${swearCount}`;
    outputDiv.appendChild(countDiv);

    if (Object.keys(userSwears).length > 0) {
      const perUserDiv = document.createElement("div");
      perUserDiv.style.marginTop = "5px";
      perUserDiv.innerHTML = "Swears per user:<br>" + 
        Object.entries(userSwears).map(([user, count]) => `${user}: ${count}`).join("<br>");
      outputDiv.appendChild(perUserDiv);
    }

    const msgDiv = document.createElement("div");
    msgDiv.style.marginTop = "15px";
    msgDiv.style.fontWeight = "bold";
    msgDiv.textContent = `Total messages: ${totalMessages}`;
    outputDiv.appendChild(msgDiv);

    if (Object.keys(userMessages).length > 0) {
      const perUserMsgDiv = document.createElement("div");
      perUserMsgDiv.style.marginTop = "5px";
      perUserMsgDiv.innerHTML = "Messages per user:<br>" + 
        Object.entries(userMessages).map(([user, count]) => `${user}: ${count}`).join("<br>");
      outputDiv.appendChild(perUserMsgDiv);
    }

    // save log file
    let logText = logLines.join("\n") + 
      `\n\nTotal swears detected: ${swearCount}`;
    if (Object.keys(userSwears).length > 0) {
      logText += "\nSwears per user:\n" + 
        Object.entries(userSwears).map(([user, count]) => `${user}: ${count}`).join("\n");
    }
    logText += `\n\nTotal messages: ${totalMessages}`;
    if (Object.keys(userMessages).length > 0) {
      logText += "\nMessages per user:\n" + 
        Object.entries(userMessages).map(([user, count]) => `${user}: ${count}`).join("\n");
    }

    const blob = new Blob([logText], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const link = document.getElementById("downloadLink");
    link.href = url;
    link.download = "messenger_chat.log";
    link.style.display = "block";
    link.textContent = "Download .log file";
  }
  </script>
</body>
</html>
