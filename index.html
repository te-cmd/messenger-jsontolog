<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Messenger JSON → Log</title>
  <style>
    body { font-family: monospace; background:#fff; color:#000; padding:20px; }
    h2 { margin-top:0; }
    .controls { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
    input[type="file"] { font-family: monospace; }
    button { padding:6px 10px; font-family: monospace; }
    #fileInfo { font-size:14px; color:#333; margin-bottom:12px; }
    #output { background:#f7f7f7; border:1px solid #ddd; padding:10px; white-space:pre-wrap; max-height:70vh; overflow:auto; }
    .log-line { margin: 6px 0; }
    .log-link { color: blue; text-decoration: underline; cursor: pointer; }
    video, audio, img { display:block; margin-top:4px; margin-bottom:4px; }
  </style>
</head>
<body>
  <h2>Messenger JSON → Log</h2>
  <div class="controls">
    <label>
      Select messages.json:
      <input type="file" id="jsonInput" accept=".json">
    </label>
    <label>
      Upload media folder:
      <input type="file" id="mediaInput" webkitdirectory directory multiple>
    </label>
    <button id="convertBtn">Convert</button>
  </div>
  <div id="fileInfo">No JSON selected · No media files loaded</div>
  <div id="output"></div>
  <a id="downloadLink" style="display:none;">Download .log file</a>

  <script>
    const playableExts = [".ogg", ".wav", ".mp4", ".mp3", ".jpeg", ".jpg", ".png"];

    // Smarter regex-based badword list
    const badWordPatterns = [
      /f+[\W_]*u+[\W_]*c+[\W_]*k+/i, // fuck
      /s+[\W_]*h+[\W_]*(i+|!+|1+)[\W_]*t+/i, // shit
      /b+[\W_]*i+[\W_]*t+[\W_]*c+[\W_]*h+/i, // bitch
      /g+[\W_]*a+[\W_]*g+[\W_]*o+/i, // gago
      /b+[\W_]*o+[\W_]*b+[\W_]*o+/i, // bobo
      /t+[\W_]*a+[\W_]*n+[\W_]*g+[\W_]*a+/i, // tanga
      /p+[\W_]*u+[\W_]*t+[\W_]*a+/i, // puta
      /h+[\W_]*a+[\W_]*y+[\W_]*o+[\W_]*p+[\W_]*k+[\W_]*a+/i, // hayopka
      /t+[\W_]*a+[\W_]*n+[\W_]*g+[\W_]*i+[\W_]*n+[\W_]*a+[\W_]*m+[\W_]*o+/i // tanginamo
    ];

    let mediaFiles = {};
    let swearCount = 0;
    let userSwears = {};
    let totalMessages = 0;
    let userMessages = {};

    // normalize paths
    function normalizePath(p) {
      if (!p) return "";
      return p.replace(/\\/g, "/").replace(/^\.\//, "").replace(/^\/+/, "");
    }

    function addMediaFileMap(file) {
      const url = URL.createObjectURL(file);
      let rel = file.webkitRelativePath ? normalizePath(file.webkitRelativePath) : normalizePath(file.name);
      const variants = new Set();
      variants.add(rel);
      variants.add("./" + rel);
      variants.add(rel.replace(/^media\//, ""));
      variants.add("media/" + file.name);
      variants.add(file.name);
      variants.add("./media/" + file.name);
      variants.forEach(k => { if (k) mediaFiles[k] = url; });
    }

    function resolveMediaUri(uri) {
      if (!uri) return null;
      const norm = normalizePath(uri);
      const candidates = [
        uri, "./" + uri, norm, "./" + norm, "media/" + norm,
        norm.replace(/^media\//,''), uri.replace(/^.\//,''), uri.split('/').pop()
      ].map(normalizePath);
      for (const c of candidates) {
        if (c && mediaFiles[c]) return mediaFiles[c];
      }
      return null;
    }

    // Improved filter function
    function filterText(text, sender) {
      let result = text;
      badWordPatterns.forEach(pattern => {
        result = result.replace(pattern, match => {
          swearCount++;
          userSwears[sender] = (userSwears[sender] || 0) + 1;
          return "#".repeat(match.length);
        });
      });
      return result;
    }

    const jsonInput = document.getElementById("jsonInput");
    const mediaInput = document.getElementById("mediaInput");
    const fileInfo = document.getElementById("fileInfo");

    mediaInput.addEventListener("change", () => {
      Object.values(mediaFiles).forEach(url => URL.revokeObjectURL(url));
      mediaFiles = {};
      const files = Array.from(mediaInput.files);
      files.forEach(addMediaFileMap);
      updateFileInfo();
    });

    jsonInput.addEventListener("change", () => {
      updateFileInfo();
    });

    function updateFileInfo() {
      const jsonName = jsonInput.files && jsonInput.files[0] ? jsonInput.files[0].name : "No JSON selected";
      const mediaCount = mediaInput.files ? mediaInput.files.length : 0;
      fileInfo.textContent = `${jsonName} · ${mediaCount} media file(s) loaded`;
    }

    document.getElementById("convertBtn").addEventListener("click", async () => {
      swearCount = 0;
      userSwears = {};
      totalMessages = 0;
      userMessages = {};

      if (!jsonInput.files || !jsonInput.files[0]) {
        alert("Please select your messages JSON file first.");
        return;
      }

      let data;
      try {
        const text = await jsonInput.files[0].text();
        data = JSON.parse(text);
      } catch (err) {
        alert("Failed to read/parse JSON: " + err.message);
        return;
      }

      const messages = data.messages || [];
      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "";
      const logLines = [];

      messages.forEach(msg => {
        const sender = msg.senderName || "Unknown";
        let ts = "Unknown time";
        if (msg.timestamp) {
          const d = new Date(msg.timestamp);
          if (!isNaN(d.getTime())) ts = d.toISOString().replace("T"," ").split(".")[0];
        }
        totalMessages++;
        userMessages[sender] = (userMessages[sender] || 0) + 1;

        let text = msg.text && msg.text.trim() ? filterText(msg.text, sender) : "";
        let lineText = `[${ts}] ${sender}: `;

        const div = document.createElement("div");
        div.className = "log-line";
        div.appendChild(document.createTextNode(lineText + (text ? text + " " : "")));

        if (msg.media && msg.media.length > 0) {
          msg.media.forEach(m => {
            const uri = m.uri || "";
            const lower = uri.toLowerCase();
            const blobUrl = resolveMediaUri(uri);

            if (blobUrl) {
              if (lower.endsWith(".mp4") || lower.endsWith(".webm")) {
                const video = document.createElement("video");
                video.src = blobUrl;
                video.controls = true;
                video.style.maxWidth = "400px";
                div.appendChild(video);
              } else if (lower.endsWith(".mp3") || lower.endsWith(".ogg") || lower.endsWith(".wav")) {
                const audio = document.createElement("audio");
                audio.src = blobUrl;
                audio.controls = true;
                div.appendChild(audio);
              } else if (lower.endsWith(".jpg") || lower.endsWith(".jpeg") || lower.endsWith(".png")) {
                const img = document.createElement("img");
                img.src = blobUrl;
                img.style.maxWidth = "400px";
                div.appendChild(img);
              } else {
                const a = document.createElement("a");
                a.href = blobUrl;
                a.download = uri.split("/").pop();
                a.textContent = `[Download ${uri}]`;
                div.appendChild(a);
              }
            } else {
              div.appendChild(document.createTextNode(`[Missing file: ${uri}]`));
            }

            logLines.push(lineText + (text ? text + " " : "") + uri);
          });
        } else {
          if (!text) text = "[Empty message]";
          div.textContent = lineText + text;
          logLines.push(lineText + text);
        }

        outputDiv.appendChild(div);
      });

      // stats
      let stats = `Total swears detected: ${swearCount}\n`;
      if (Object.keys(userSwears).length > 0) {
        stats += "Swears per user:\n" + Object.entries(userSwears).map(([u,c]) => `${u}: ${c}`).join("\n") + "\n";
      }
      stats += `\nTotal messages: ${totalMessages}\n`;
      if (Object.keys(userMessages).length > 0) {
        stats += "Messages per user:\n" + Object.entries(userMessages).map(([u,c]) => `${u}: ${c}`).join("\n");
      }

      const statsDiv = document.createElement("div");
      statsDiv.style.marginTop = "12px";
      statsDiv.textContent = stats;
      outputDiv.appendChild(statsDiv);

      // download log
      const logText = logLines.join("\n") + "\n\n" + stats;
      const blob = new Blob([logText], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.getElementById("downloadLink");
      link.href = url;
      link.download = "messenger_chat.log";
      link.style.display = "inline-block";
      link.textContent = "Download .log file";
    });
  </script>
</body>
</html>
